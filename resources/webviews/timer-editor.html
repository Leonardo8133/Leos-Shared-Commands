<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="Content-Security-Policy" content="default-src 'none'; style-src {{cspSource}} 'unsafe-inline' https://cdn.jsdelivr.net; script-src 'nonce-{{nonce}}'; font-src https://cdn.jsdelivr.net; img-src {{cspSource}} data:;" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@vscode/codicons@0.0.36/dist/codicon.css" />
    <title>Timer Editor</title>
    <style>
      body {
        margin: 0;
        font-family: var(--vscode-font-family);
        color: var(--vscode-foreground);
        background: var(--vscode-editor-background);
      }
      .container {
        padding: 16px;
        display: flex;
        flex-direction: column;
        gap: 16px;
      }
      h1 {
        margin: 0;
        font-size: 16px;
      }
      .section {
        border: 1px solid var(--vscode-panel-border);
        border-radius: 6px;
        background: var(--vscode-editor-background);
        padding: 10px;
        display: flex;
        flex-direction: column;
        gap: 10px;
      }
      .section-title {
        margin: 0;
        font-size: 13px;
        font-weight: 600;
      }
      .field {
        display: flex;
        flex-direction: column;
        gap: 4px;
      }
      .field label {
        font-size: 11px;
        color: var(--vscode-descriptionForeground);
        text-transform: uppercase;
        letter-spacing: 0.04em;
      }
      .field input,
      .field textarea {
        width: calc(100% - 15px);
        padding: 6px;
        border: 1px solid var(--vscode-input-border);
        border-radius: 4px;
        background: var(--vscode-input-background);
        color: var(--vscode-input-foreground);
        font-size: 12px;
      }
      .field input[type="checkbox"] {
        width: auto;
      }
      .field input[type="datetime-local"] {
        width: calc(100% - 15px);
      }
      .field input[readonly] {
        background: var(--vscode-input-background);
        opacity: 0.6;
        cursor: not-allowed;
      }
      .subtimer-elapsed {
        font-size: 11px;
        color: var(--vscode-descriptionForeground);
        margin-left: 8px;
      }
      .subtimer-interval {
        margin: 4px 0;
        padding: 4px;
        background: var(--vscode-input-background);
        border-radius: 3px;
        font-size: 11px;
      }
      textarea {
        font-family: var(--vscode-editor-font-family, monospace);
        min-height: 40px;
        resize: vertical;
      }
      .row {
        display: flex;
        align-items: center;
        gap: 8px;
      }
      .grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
        gap: 12px;
      }
      .subtimers-list {
        display: flex;
        flex-direction: column;
        gap: 8px;
      }
      .subtimer-item {
        border: 1px solid var(--vscode-panel-border);
        border-radius: 4px;
        padding: 10px;
        background: var(--vscode-editor-background);
        cursor: move;
        display: flex;
        flex-direction: column;
        gap: 8px;
      }
      .subtimer-item.dragging {
        opacity: 0.5;
      }
      .subtimer-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
      }
      .subtimer-title {
        font-weight: 600;
        font-size: 13px;
      }
      .subtimer-actions {
        display: flex;
        gap: 4px;
      }
      .btn-icon {
        background: transparent;
        border: none;
        color: var(--vscode-foreground);
        cursor: pointer;
        padding: 4px;
        border-radius: 3px;
        display: flex;
        align-items: center;
        justify-content: center;
      }
      .btn-icon:hover {
        background: var(--vscode-button-hoverBackground);
      }
      .subtimer-details {
        display: flex;
        flex-direction: column;
        gap: 6px;
        margin-top: 4px;
      }
      .subtimer-details.hidden {
        display: none;
      }
      .subtimer-description {
        font-size: 11px;
        color: var(--vscode-descriptionForeground);
        font-style: italic;
      }
      .subtimer-dates {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 8px;
      }
      .actions {
        display: flex;
        gap: 8px;
        justify-content: flex-end;
        margin-top: 12px;
      }
      button {
        border: none;
        border-radius: 4px;
        padding: 6px 14px;
        font-size: 13px;
        cursor: pointer;
      }
      .btn-primary {
        background: var(--vscode-button-background);
        color: var(--vscode-button-foreground);
      }
      .btn-primary:hover {
        background: var(--vscode-button-hoverBackground);
      }
      .btn-secondary {
        background: transparent;
        border: 1px solid var(--vscode-button-border, var(--vscode-button-background));
        color: var(--vscode-button-foreground);
      }
      .btn-danger {
        background: var(--vscode-errorForeground);
        color: white;
      }
      .drag-handle {
        cursor: move;
        color: var(--vscode-descriptionForeground);
        margin-right: 8px;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <h1>Edit Timer</h1>

      <div class="section">
        <h2 class="section-title">Timer Information</h2>
        <div class="field">
          <label>Label</label>
          <input type="text" id="timerLabel" placeholder="Timer label" />
        </div>
        <div class="row">
          <input type="checkbox" id="timerArchived" />
          <label for="timerArchived" style="text-transform: none; margin: 0;">Archived</label>
        </div>
      </div>

      <div class="section">
        <h2 class="section-title">Timer Dates</h2>
        <div class="grid">
          <div class="field">
            <label>Start Time</label>
            <input type="datetime-local" id="timerStartTime" readonly />
          </div>
          <div class="field">
            <label>End Time</label>
            <input type="datetime-local" id="timerEndTime" readonly />
          </div>
        </div>
        <div id="subtimerIntervals" style="margin-top: 10px; font-size: 11px; color: var(--vscode-descriptionForeground);">
          <!-- Subtimer intervals will be shown here -->
        </div>
      </div>

      <div class="section">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
          <h2 class="section-title" style="margin: 0;">SubTimers</h2>
          <button class="btn-secondary" id="createSubTimerBtn" style="font-size: 11px; padding: 4px 8px;">
            <span class="codicon codicon-add"></span> Create SubTimer
          </button>
        </div>
        <div id="subtimersList" class="subtimers-list">
          <!-- Subtimers will be rendered here -->
        </div>
      </div>

      <div class="section">
        <h2 class="section-title">Logs</h2>
        <div id="logsList" style="max-height: 300px; overflow-y: auto; font-family: var(--vscode-editor-font-family, monospace); font-size: 11px; line-height: 1.6; color: var(--vscode-descriptionForeground);">
          <!-- Logs will be rendered here -->
        </div>
      </div>

      <div class="actions">
        <button class="btn-secondary" id="cancelBtn">Cancel</button>
        <button class="btn-primary" id="saveBtn">Save</button>
      </div>
    </div>

    <script nonce="{{nonce}}">
      const vscode = acquireVsCodeApi();
      let currentTimer = null;
      let draggedElement = null;

      // Convert ISO string to datetime-local format
      function isoToLocalDateTime(isoString) {
        if (!isoString) return '';
        const date = new Date(isoString);
        const year = date.getFullYear();
        const month = String(date.getMonth() + 1).padStart(2, '0');
        const day = String(date.getDate()).padStart(2, '0');
        const hours = String(date.getHours()).padStart(2, '0');
        const minutes = String(date.getMinutes()).padStart(2, '0');
        return `${year}-${month}-${day}T${hours}:${minutes}`;
      }

      // Convert datetime-local to ISO string
      function localDateTimeToIso(localDateTime) {
        if (!localDateTime) return undefined;
        return new Date(localDateTime).toISOString();
      }

      function renderLogs() {
        const container = document.getElementById('logsList');
        if (!currentTimer || !currentTimer.logs || currentTimer.logs.length === 0) {
          container.innerHTML = '<div style="color: var(--vscode-descriptionForeground); font-size: 12px;">No logs available</div>';
          return;
        }

        container.innerHTML = currentTimer.logs.slice().reverse().map(log => {
          return `<div style="padding: 2px 0; border-bottom: 1px solid var(--vscode-panel-border);">${escapeHtml(log)}</div>`;
        }).join('');
      }

      function renderSubtimers() {
        const container = document.getElementById('subtimersList');
        if (!currentTimer || !currentTimer.subtimers || currentTimer.subtimers.length === 0) {
          container.innerHTML = '<div style="color: var(--vscode-descriptionForeground); font-size: 12px;">No subtimers</div>';
          return;
        }

        container.innerHTML = currentTimer.subtimers.map((subtimer, index) => {
          const startTime = isoToLocalDateTime(subtimer.startTime);
          const endTime = isoToLocalDateTime(subtimer.endTime);
          const elapsedMs = calculateSubtimerElapsedTime(subtimer);
          const elapsedTime = formatElapsedTime(elapsedMs);
          return `
            <div class="subtimer-item" data-subtimer-id="${subtimer.id}" draggable="true">
              <div class="subtimer-header">
                <div style="display: flex; align-items: center;">
                  <span class="drag-handle codicon codicon-gripper" style="font-size: 14px;"></span>
                  <span class="subtimer-title">${escapeHtml(subtimer.label)}</span>
                  <span class="subtimer-elapsed">${elapsedTime}</span>
                </div>
                <div class="subtimer-actions">
                  <button class="btn-icon codicon codicon-edit" title="Rename" data-action="edit" data-subtimer-id="${subtimer.id}"></button>
                  <button class="btn-icon codicon codicon-trash" title="Delete" data-action="delete" data-subtimer-id="${subtimer.id}"></button>
                  <button class="btn-icon codicon codicon-chevron-down" title="Toggle Details" data-action="toggle" data-subtimer-id="${subtimer.id}"></button>
                </div>
              </div>
              <div class="subtimer-details hidden" id="details-${subtimer.id}">
                <div class="field">
                  <label>Label</label>
                  <input type="text" id="st-label-${subtimer.id}" value="${escapeHtml(subtimer.label)}" />
                </div>
                <div class="field">
                  <label>Description</label>
                  <textarea id="st-desc-${subtimer.id}" rows="2">${escapeHtml(subtimer.description || '')}</textarea>
                </div>
                <div class="subtimer-dates">
                  <div class="field">
                    <label>Start Time</label>
                    <input type="datetime-local" id="st-start-${subtimer.id}" value="${startTime}" />
                  </div>
                  <div class="field">
                    <label>End Time</label>
                    <input type="datetime-local" id="st-end-${subtimer.id}" value="${endTime}" />
                  </div>
                </div>
                <div style="display: flex; gap: 4px; margin-top: 4px;">
                  <button class="btn-secondary save-subtimer-btn" style="font-size: 11px; padding: 4px 8px;" data-subtimer-id="${subtimer.id}">Save Changes</button>
                </div>
              </div>
            </div>
          `;
        }).join('');

        // Add drag and drop handlers
        container.querySelectorAll('.subtimer-item').forEach(item => {
          item.addEventListener('dragstart', handleDragStart);
          item.addEventListener('dragover', handleDragOver);
          item.addEventListener('drop', handleDrop);
          item.addEventListener('dragend', handleDragEnd);
        });

        // Add event listeners for buttons (fixing CSP issues)
        container.querySelectorAll('[data-action="edit"]').forEach(btn => {
          btn.addEventListener('click', (e) => {
            const subtimerId = e.target.getAttribute('data-subtimer-id');
            editSubTimer(subtimerId);
          });
        });

        container.querySelectorAll('[data-action="delete"]').forEach(btn => {
          btn.addEventListener('click', (e) => {
            const subtimerId = e.target.getAttribute('data-subtimer-id');
            deleteSubTimer(subtimerId);
          });
        });

        container.querySelectorAll('[data-action="toggle"]').forEach(btn => {
          btn.addEventListener('click', (e) => {
            const subtimerId = e.target.getAttribute('data-subtimer-id');
            toggleSubtimerDetails(subtimerId);
          });
        });

        container.querySelectorAll('.save-subtimer-btn').forEach(btn => {
          btn.addEventListener('click', (e) => {
            const subtimerId = e.target.getAttribute('data-subtimer-id');
            saveSubTimer(subtimerId);
          });
        });

        // Update subtimer intervals display
        updateSubtimerIntervals();
      }

      function calculateSubtimerElapsedTime(subtimer) {
        // Calculate elapsed time accounting for pauses
        const totalElapsed = subtimer.totalElapsedTime !== undefined ? subtimer.totalElapsedTime : 0;
        
        if (subtimer.endTime) {
          // Subtimer is paused/stopped - use accumulated elapsed time
          // For backward compatibility: if totalElapsedTime is 0 and we have endTime, calculate from start
          if (totalElapsed === 0 && !subtimer.lastResumeTime) {
            const start = new Date(subtimer.startTime);
            const end = new Date(subtimer.endTime);
            return end - start;
          }
          return totalElapsed;
        } else {
          // Subtimer is running - add current running segment to accumulated time
          const lastResumeTime = subtimer.lastResumeTime 
            ? new Date(subtimer.lastResumeTime) 
            : new Date(subtimer.startTime);
          const now = new Date();
          const currentSegment = now - lastResumeTime;
          
          // For backward compatibility: if totalElapsedTime is 0, calculate from start
          if (totalElapsed === 0 && !subtimer.lastResumeTime) {
            const start = new Date(subtimer.startTime);
            return now - start;
          }
          
          return totalElapsed + currentSegment;
        }
      }

      function calculateElapsedTime(startTime, endTime) {
        const start = new Date(startTime);
        const end = endTime ? new Date(endTime) : new Date();
        const diffMs = end - start;
        const diffSeconds = Math.floor(diffMs / 1000);
        const hours = Math.floor(diffSeconds / 3600);
        const minutes = Math.floor((diffSeconds % 3600) / 60);
        const secs = diffSeconds % 60;

        if (hours > 0) {
          return `${hours}h ${minutes}m ${secs}s`;
        } else if (minutes > 0) {
          return `${minutes}m ${secs}s`;
        } else {
          return `${secs}s`;
        }
      }

      function formatElapsedTime(ms) {
        const diffSeconds = Math.floor(ms / 1000);
        const hours = Math.floor(diffSeconds / 3600);
        const minutes = Math.floor((diffSeconds % 3600) / 60);
        const secs = diffSeconds % 60;

        if (hours > 0) {
          return `${hours}h ${minutes}m ${secs}s`;
        } else if (minutes > 0) {
          return `${minutes}m ${secs}s`;
        } else {
          return `${secs}s`;
        }
      }

      function formatDateTime(isoString) {
        if (!isoString) return 'N/A';
        const date = new Date(isoString);
        return date.toLocaleString();
      }

      function updateSubtimerIntervals() {
        const intervalsContainer = document.getElementById('subtimerIntervals');
        if (!currentTimer || !currentTimer.subtimers || currentTimer.subtimers.length === 0) {
          intervalsContainer.innerHTML = '';
          return;
        }

        const intervals = currentTimer.subtimers.map((subtimer, index) => {
          const startTime = formatDateTime(subtimer.startTime);
          const endTime = subtimer.endTime ? formatDateTime(subtimer.endTime) : 'Running...';
          const elapsedMs = calculateSubtimerElapsedTime(subtimer);
          const elapsed = formatElapsedTime(elapsedMs);
          return `<div class="subtimer-interval">${index + 1}. ${escapeHtml(subtimer.label)}: ${startTime} â†’ ${endTime} (${elapsed})</div>`;
        }).join('');

        intervalsContainer.innerHTML = intervals;
      }

      function escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
      }

      function handleDragStart(e) {
        draggedElement = this;
        this.classList.add('dragging');
        e.dataTransfer.effectAllowed = 'move';
      }

      function handleDragOver(e) {
        e.preventDefault();
        e.dataTransfer.dropEffect = 'move';
        const afterElement = getDragAfterElement(document.getElementById('subtimersList'), e.clientY);
        if (afterElement == null) {
          document.getElementById('subtimersList').appendChild(draggedElement);
        } else {
          document.getElementById('subtimersList').insertBefore(draggedElement, afterElement);
        }
      }

      function handleDrop(e) {
        e.preventDefault();
        this.classList.remove('dragging');
      }

      function handleDragEnd(e) {
        this.classList.remove('dragging');
        saveSubTimerOrder();
      }

      function getDragAfterElement(container, y) {
        const draggableElements = [...container.querySelectorAll('.subtimer-item:not(.dragging)')];
        return draggableElements.reduce((closest, child) => {
          const box = child.getBoundingClientRect();
          const offset = y - box.top - box.height / 2;
          if (offset < 0 && offset > closest.offset) {
            return { offset: offset, element: child };
          } else {
            return closest;
          }
        }, { offset: Number.NEGATIVE_INFINITY }).element;
      }

      function saveSubTimerOrder() {
        const container = document.getElementById('subtimersList');
        const subtimerIds = Array.from(container.querySelectorAll('.subtimer-item')).map(item => 
          item.getAttribute('data-subtimer-id')
        );
        vscode.postMessage({
          type: 'reorderSubTimers',
          subtimerIds: subtimerIds
        });
      }

      function toggleSubtimerDetails(subtimerId) {
        const details = document.getElementById(`details-${subtimerId}`);
        details.classList.toggle('hidden');
      }

      function editSubTimer(subtimerId) {
        const details = document.getElementById(`details-${subtimerId}`);
        if (details.classList.contains('hidden')) {
          details.classList.remove('hidden');
        }
      }

      function saveSubTimer(subtimerId) {
        const label = document.getElementById(`st-label-${subtimerId}`).value;
        const description = document.getElementById(`st-desc-${subtimerId}`).value;
        const startTime = localDateTimeToIso(document.getElementById(`st-start-${subtimerId}`).value);
        const endTime = localDateTimeToIso(document.getElementById(`st-end-${subtimerId}`).value);

        vscode.postMessage({
          type: 'editSubTimer',
          subtimerId: subtimerId,
          label: label,
          description: description || undefined
        });

        if (startTime || endTime) {
          vscode.postMessage({
            type: 'updateSubTimerDates',
            subtimerId: subtimerId,
            startTime: startTime,
            endTime: endTime
          });
        }
      }

      // Periodically update elapsed times for running subtimers
      setInterval(() => {
        if (currentTimer && currentTimer.subtimers) {
          const hasRunningSubtimer = currentTimer.subtimers.some(st => !st.endTime);
          if (hasRunningSubtimer) {
            // Update elapsed time displays
            currentTimer.subtimers.forEach(subtimer => {
              const item = document.querySelector(`[data-subtimer-id="${subtimer.id}"]`);
              if (item) {
                const elapsedSpan = item.querySelector('.subtimer-elapsed');
                if (elapsedSpan) {
                  const elapsedMs = calculateSubtimerElapsedTime(subtimer);
                  elapsedSpan.textContent = formatElapsedTime(elapsedMs);
                }
              }
            });
            updateSubtimerIntervals();
          }
        }
      }, 1000); // Update every second

      function deleteSubTimer(subtimerId) {
        if (confirm('Delete this subtimer?')) {
          vscode.postMessage({
            type: 'deleteSubTimer',
            subtimerId: subtimerId
          });
        }
      }

      document.getElementById('saveBtn').addEventListener('click', () => {
        const label = document.getElementById('timerLabel').value;
        const archived = document.getElementById('timerArchived').checked;

        vscode.postMessage({
          type: 'saveTimer',
          timer: {
            ...currentTimer,
            label: label,
            archived: archived
          }
        });
      });

      document.getElementById('cancelBtn').addEventListener('click', () => {
        vscode.postMessage({ type: 'cancel' });
      });

      document.getElementById('createSubTimerBtn').addEventListener('click', () => {
        vscode.postMessage({
          type: 'createSubTimer',
          timerId: currentTimer.id
        });
      });

      window.addEventListener('message', event => {
        const message = event.data;
        switch (message.type) {
          case 'timerState':
            currentTimer = message.timer;
            document.getElementById('timerLabel').value = currentTimer.label || '';
            document.getElementById('timerArchived').checked = currentTimer.archived || false;
            document.getElementById('timerStartTime').value = isoToLocalDateTime(currentTimer.startTime);
            // Timer doesn't have endTime, calculate from subtimers
            const hasRunningSubtimer = currentTimer.subtimers && currentTimer.subtimers.some(st => !st.endTime);
            if (!hasRunningSubtimer && currentTimer.subtimers && currentTimer.subtimers.length > 0) {
              // Find the latest end time
              const latestEndTime = currentTimer.subtimers
                .map(st => st.endTime ? new Date(st.endTime) : null)
                .filter(d => d !== null)
                .sort((a, b) => b - a)[0];
              if (latestEndTime) {
                document.getElementById('timerEndTime').value = isoToLocalDateTime(latestEndTime.toISOString());
              } else {
                document.getElementById('timerEndTime').value = '';
              }
            } else {
              document.getElementById('timerEndTime').value = '';
            }
            renderSubtimers();
            updateSubtimerIntervals();
            renderLogs();
            break;
        }
      });

      // Notify that we're ready
      vscode.postMessage({ type: 'ready' });
    </script>
  </body>
</html>

